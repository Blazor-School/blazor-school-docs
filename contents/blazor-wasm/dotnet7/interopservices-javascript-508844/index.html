<h1><code>InteropServices.JavaScript</code></h1>
<p>🟥 Not applicable to Blazor Server</p>
<p><code>InteropServices.JavaScript</code> is a feature exclusive to Blazor WebAssembly, which offers its own unique advantages over <code>IJSRuntime</code>. In this tutorial, you will learn about:</p>
<ul>
    <li>The benefits of using <code>InteropServices.JavaScript</code> over <code>IJSRuntime</code></li>
    <li>Understanding the marshalling process</li>
    <li>Enabling <code>InteropServices.JavaScript</code></li>
    <li>Importing JavaScript code</li>
    <li>Invoking JavaScript code from .NET</li>
    <li>Invoking .NET code from JavaScript</li>
</ul>
<blockquote>You can <a href="https://github.com/Blazor-School/javascript-interaction-blazor-wasm-dotnet7" target="_blank" rel="noopener">download the example</a> code used in this topic on GitHub.</blockquote>
<hr class="my-4" />
<h1>The benefits of using <code>InteropServices.JavaScript</code> over <code>IJSRuntime</code></h1>
<p>There are three primary advantages of using <code>InteropServices.JavaScript</code> over <code>IJSRuntime</code>:</p>
<ol>
    <li>It is ideal for modularized JavaScript code.</li>
    <li>Developers can control the marshalling process without needing to write additional code.</li>
    <li>The lifetimes of C# instances in JavaScript and JavaScript instances in C# are managed.</li>
</ol>
<p>However, <code>InteropServices.JavaScript</code> cannot be used with unpredictable JavaScript functions.</p>
<h3>Better support for modularized JavaScript code</h3>
<p>While <code>IJSRuntime</code> enables the invocation of a JavaScript function that is attached to a module or the window object by its name, <code>InteropServices.JavaScript</code> maps a JavaScript function to a C# method. For instance, consider the following example that maps the JavaScript function <code>console.log</code> to a C# method:</p>
<p>Using <code>IJSRuntime</code>:</p>
<pre class="code" language="csharp">public class ConsoleWrapper
{
    private readonly IJSRuntime _js;

    public ConsoleWrapper(IJSRuntime js)
	{
        _js = js;
    }

    public async Task Log(string message)
    {
        await _js.InvokeVoidAsync("console.log", message);
    }
}</pre>
<p>Using <code>InteropServices.JavaScript</code>:</p>
<pre class="code" language="csharp">public static partial class ConsoleWrapper
{
    [JSImport("globalThis.console.log")]
    public static partial void Log(string message);
}</pre>
<h3>Control the marshalling process</h3>
<p><code>IJSRuntime</code> is a versatile tool that can be used to invoke any JavaScript function from .NET. Whereas, one limitation of <code>InteropServices.JavaScript</code> is that it can only invoke JavaScript functions with a single return type. This means that the code structure of the JavaScript function must be carefully considered when using <code>InteropServices.JavaScript</code>.</p>
<p>Using <code>IJSRuntime</code>:</p>
<pre class="code" language="csharp">public async Task MyMethod() 
{
    await MyModule.Value.InvokeVoidAsync("MyFunction", 5);
}</pre>
<p>If we want to convert the received number into a <code>BigInt</code>, we need to write additional JavaScript code:</p>
<pre class="code" language="javascript">export function MyFunction(number)
{
    let bigintNumber = BigInt(number);
}</pre>
<p>On the other hand, by using <code>InteropServices.JavaScript</code>, we can simplify the process and eliminate the need for additional code:</p>
<pre class="code" language="csharp">[JSImport("MyFunction", "MyModule")]
public static partial void MyMethod([JSMarshalAs&lt;JSType.BigInt&gt;] long number);</pre>
<p>With this approach, the received parameter on the JavaScript side is already a <code>BigInt</code>, making the code more efficient and easier to maintain.</p>
<h3>Managed lifetime</h3>
<p>One of the major advantages of using C# is its garbage collection (GC) feature. However, when using <code>IJSRuntime</code>, the GC is unable to collect the module instance of C# that is referenced by JavaScript code. To overcome this issue, <code>InteropServices.JavaScript</code> can be used so that you don't need to worry about when a JavaScript module is destroyed. You just need to import the module every time you require it. Importing the JavaScript module multiple times does not impact performance as the module is automatically cached.</p>
<hr class="my-4" />
<h1>Understanding the marshalling process</h1>
<p>JavaScript and C# have their own distinct data types. When integrating between them, it's necessary to marshal the parameters to the other data type because C# cannot recognize the JavaScript type, and vice versa. The following image provides a clear illustration of the marshalling process.</p>
<p><img src="contents\blazor-wasm\dotnet7\interopservices-javascript-508844\marshalling-process-blazor.png" alt="marshalling-process-blazor.png" width="900" height="461" /></p>
<p>Here are the table of interchangeable common data type between JavaScript and C#.</p>
<div class="table-responsive">
    <table class="table table-hover table-bordered">
        <tbody>
            <tr>
                <td>JavaScript type</td>
                <td>.NET type</td>
            </tr>
            <tr>
                <td><code>Boolean</code></td>
                <td><code>Boolean</code></td>
            </tr>
            <tr>
                <td><code>Number</code></td>
                <td><code>Byte</code></td>
            </tr>
            <tr>
                <td><code>String</code></td>
                <td><code>Char</code>, <code>char</code>, <code>String</code>, <code>string</code></td>
            </tr>
            <tr>
                <td><code>Number</code></td>
                <td><code>Int16</code>, <code>short</code>, <code>Int32</code>, <code>int</code>, <code>Int64</code>, <code>long</code>, <code>Single</code>, <code>float</code>, <code>Double</code>, <code>double</code>, <code>IntPtr</code></td>
            </tr>
            <tr>
                <td><code>BigInt</code></td>
                <td><code>Int64</code>, <code>long</code></td>
            </tr>
            <tr>
                <td><code>Date</code></td>
                <td><code>DateTime</code>, <code>DateTimeOffset</code></td>
            </tr>
            <tr>
                <td><code>Error</code></td>
                <td><code>Exception</code></td>
            </tr>
            <tr>
                <td><code>Object</code></td>
                <td><code>JSObject</code></td>
            </tr>
            <tr>
                <td><code>Any</code></td>
                <td><code>Object</code></td>
            </tr>
            <tr>
                <td><code>Promise</code></td>
                <td><code>Task</code></td>
            </tr>
            <tr>
                <td><code>Function</code></td>
                <td><code>Action</code>, <code>Action&lt;T&gt;</code>, <code>Action&lt;T1, T2&gt;</code>, <code>Action&lt;T1, T2, T3&gt;</code>, <code>Func&lt;TResult&gt;</code>, <code>Func&lt;T, TResult&gt;</code>, <code>Func&lt;T1, T2, TResult&gt;</code>, <code>Func&lt;T1, T2, T3, TResult&gt;</code></td>
            </tr>
        </tbody>
    </table>
</div>
<hr class="my-4" />
<h1>Enabling <code>InteropServices.JavaScript</code></h1>
<p>Enabling unsafe code is necessary when integrating with another programming language, including JavaScript. To integrate with JavaScript, you'll need to enable unsafe code in your project by following these steps:</p>
<ol>
    <li>Right-click on your project and select <strong>Properties</strong> to open the project properties.</li>
</ol>
<p><img src="contents\blazor-wasm\dotnet7\interopservices-javascript-508844\open-project-properties.png" alt="open-project-properties.png" width="424" height="825" /></p>
<ol start="2">
    <li>Navigate to <strong>Build </strong>&rarr;<strong> General</strong> and select the checkbox for <strong>Unsafe code</strong>.</li>
</ol>
<p><img src="contents\blazor-wasm\dotnet7\interopservices-javascript-508844\allow-unsafe-code.png" alt="allow-unsafe-code.png" width="819" height="804" /></p>
<hr class="my-4" />
<h1>Importing JavaScript code</h1>
<p>You can place your JavaScript code file either in the <strong>wwwroot</strong> folder or in the same directory as the corresponding component. For standard JavaScript, import it in the <strong>index.html</strong> and create a C# wrapper. When working with JavaScript modules, you have the option to either create a C# wrapper that is imported only when needed, or import it when the application starts. Importing the module only when needed is recommended for optimal performance.</p>
<h3>Build a C# wrapper for a global standard JavaScript</h3>
<p>Assuming you have the following standard JavaScript that you want to import into your Blazor project:</p>
<p><strong>wwwroot/js/GlobalClassicJavaScript.js</strong>:</p>
<pre class="code" language="javascript">function HelloBlazorSchool()
{
    alert(`Hello Blazor School from Global standard JS.`);
}</pre>
<ol>
    <li>In the <strong>index.html</strong> file, import the standard JavaScript file:</li>
</ol>
<pre class="code" language="html">&lt;body&gt;
    ...
    &lt;script src="js/GlobalClassicJavaScript.js"&gt;&lt;/script&gt;
&lt;/body&gt;</pre>
<ol start="2">
    <li>Create a C# wrapper class.</li>
</ol>
<pre class="code" language="csharp">[[SupportedOSPlatform("browser")]
public partial class ClassicJavaScript
{
    [JSImport("globalThis.HelloBlazorSchool")]
    public static partial void HelloBlazorSchool();
}</pre>
<p>In the above example, the first parameter of <code>JSImport</code> attribute is the function name that you want to map. In this case, it's <code>HelloBlazorSchool</code>. Note that the <code>globalThis</code> object in the JavaScript code is a special object created by Blazor, and it's a reference to the <code>window</code> object.</p>
<h3>Build a C# wrapper for a JavaScript module</h3>
<p>Assuming you have the following JavaScript Module that you want to import into your Blazor project:</p>
<p><strong>wwwroot/js/JavaScriptModule.js</strong>:</p>
<pre class="code" language="javascript">export function HelloBlazorSchool()
{
    alert("Hello Blazor School!");
}</pre>
<ol>
    <li>Create a C# class:</li>
</ol>
<pre class="code" language="csharp">[SupportedOSPlatform("browser")]
public partial class JavaScriptModule
{
    public static async Task ImportModuleAsync() =&gt; await JSHost.ImportAsync("MyModule", "/js/JavaScriptModule.js");

    [JSImport("HelloBlazorSchool", "MyModule")]
    public static partial void HelloBlazorSchool();
}</pre>
<ol start="2">
    <li>Call the <code>ImportModuleAsync</code> method to load the JavaScript module. This method can be called multiple times without sending a request if the file is already loaded. There are two options for when to call this method:</li>
</ol>
<p>Eager loading: Load the JavaScript module in <strong>Program.cs</strong>. This will slow down your website for the first load, but subsequent loads will be faster.</p>
<pre class="code" language="csharp">builder.Services...

if (OperatingSystem.IsBrowser())
{
    await JavaScriptModule.ImportModuleAsync();
}</pre>
<p>Lazy loading: Load the JavaScript module in a Razor Component, during the OnInit or OnAfterRender phase. This will not slow down your website for the first load.</p>
<pre class="code" language="razor">@code { 
   protected override async Task OnInitializedAsync()
    {
        await JavaScriptModule.ImportModuleAsync();
    }
}</pre>
<pre class="code" language="razor">@code { 
   protected override Task OnAfterRenderAsync(bool firstRender)
    {
        await JavaScriptModule.ImportModuleAsync();
    }
}</pre>
<p>With the C# wrapper in place, you can now use the JavaScript module in your Blazor project by calling the <code>HelloBlazorSchool</code> method.</p>
<h3>Build a C# wrapper for a colocated JavaScript module</h3>
<p>To create a C# wrapper for a colocated JavaScript module using <code>InteropServices.JavaScript</code>, you need to follow these steps:</p>
<ol>
    <li>Place the JavaScript module in the same folder as the component.</li>
</ol>
<p><img src="contents\blazor-wasm\dotnet7\interopservices-javascript-508844\colocate-javascript-module.png" alt="colocate-javascript-module.png" width="400" height="100" /></p>
<ol start="2">
    <li>Create a partial class for the component with the following code:</li>
</ol>
<pre class="code" language="csharp">[SupportedOSPlatform("browser")]
public partial class CallJavaScriptFunction
{
    public static async Task ImportModuleAsync() =&gt; await JSHost.ImportAsync("Collocated Module", "../Pages/InteropServices/CallJavaScriptFunction.razor.js");

    [JSImport("HelloBlazorSchool", "Collocated Module")]
    static partial void CallCollocatedJSModuleFunction();
}</pre>
<ol start="3">
    <li>Import the JavaScript module during the OnInit or OnAfterRender phase:</li>
</ol>
<pre class="code" language="razor">@code { 
   protected override async Task OnInitializedAsync()
    {
        await ImportModuleAsync();
    }
}</pre>
<pre class="code" language="razor">@code { 
   protected override Task OnAfterRenderAsync(bool firstRender)
    {
        await ImportModuleAsync();
    }
}</pre>
<p>By following these steps, you can easily create a C# wrapper for a colocated JavaScript module and use it in your Blazor project.</p>
<hr class="my-4" />
<h1>Invoking JavaScript code from .NET</h1>
<p></p>